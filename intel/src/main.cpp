#include <windows.h>
#include <iostream>
#include <chrono>
#include <memory>
#include <d3d11.h>
#include <dxgi.h>
#include <wrl/client.h>
#include "audio_video_player.h"
using Microsoft::WRL::ComPtr; LRESULT CALLBACK WndProc(HWND h, UINT m, WPARAM w, LPARAM l){ if(m==WM_DESTROY){ PostQuitMessage(0); return 0;} if(m==WM_KEYDOWN && w==VK_ESCAPE){ PostQuitMessage(0); return 0;} return DefWindowProc(h,m,w,l);} bool createSwapChain(HWND hwnd, ComPtr<ID3D11Device> dev, ComPtr<IDXGISwapChain>& sc){ DXGI_SWAP_CHAIN_DESC d={}; d.BufferCount=2; d.BufferDesc.Width=1280; d.BufferDesc.Height=720; d.BufferDesc.Format=DXGI_FORMAT_R8G8B8A8_UNORM; d.BufferUsage=DXGI_USAGE_RENDER_TARGET_OUTPUT; d.OutputWindow=hwnd; d.SampleDesc.Count=1; d.Windowed=TRUE; d.SwapEffect=DXGI_SWAP_EFFECT_FLIP_DISCARD; ComPtr<IDXGIDevice> gidev; if(FAILED(dev.As(&gidev))) return false; ComPtr<IDXGIAdapter> ad; if(FAILED(gidev->GetAdapter(&ad))) return false; ComPtr<IDXGIFactory> fa; if(FAILED(ad->GetParent(IID_PPV_ARGS(&fa)))) return false; return SUCCEEDED(fa->CreateSwapChain(dev.Get(), &d, &sc)); }
int main(int argc,char* argv[]){ if(argc<2){ std::cerr<<"Usage: 3d_player_intel.exe <video>"<<std::endl; return 1; } std::string path=argv[1]; WNDCLASS wc{}; wc.lpfnWndProc=WndProc; wc.hInstance=GetModuleHandle(nullptr); wc.lpszClassName=L"IntelPlayerWnd"; RegisterClass(&wc); HWND hwnd=CreateWindowW(L"IntelPlayerWnd", L"Intel Player", WS_OVERLAPPEDWINDOW|WS_VISIBLE, CW_USEDEFAULT,CW_USEDEFAULT,1280,720,nullptr,nullptr,wc.hInstance,nullptr); if(!hwnd){ std::cerr<<"CreateWindow failed"<<std::endl; return 1;} auto avp=std::make_unique<AudioVideoPlayer>(); if(!avp->open(path)){ std::cerr<<"Open failed"<<std::endl; return 1;} ComPtr<ID3D11Device> dev(avp->getD3D11Device()); if(!dev){ std::cerr<<"No device"<<std::endl; return 1;} dev->AddRef(); ComPtr<IDXGISwapChain> sc; if(!createSwapChain(hwnd, dev, sc)){ std::cerr<<"SwapChain failed"<<std::endl; return 1;} if(!avp->setRenderTarget(sc)){ std::cerr<<"SetRenderTarget failed"<<std::endl; return 1;} if(avp->hasAudio()) avp->initializeAudio(); auto start=std::chrono::high_resolution_clock::now(); MSG msg{}; while(msg.message!=WM_QUIT){ if(PeekMessage(&msg,nullptr,0,0,PM_REMOVE)){ TranslateMessage(&msg); DispatchMessage(&msg);} else { double t=std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-start).count(); avp->onTimer(t); if(avp->isEOF()) PostQuitMessage(0); Sleep(1);} } avp->close(); return 0; }
