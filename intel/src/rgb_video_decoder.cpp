#include "rgb_video_decoder.h"
#include <iostream>

extern "C" {
#include <libavutil/hwcontext_d3d11va.h>
}

RgbVideoDecoder::RgbVideoDecoder():hw_decoder_(std::make_unique<HwVideoDecoder>()){}
RgbVideoDecoder::~RgbVideoDecoder(){ close(); }
bool RgbVideoDecoder::open(const std::string& filepath){ if(isOpen()) close(); if(!hw_decoder_->open(filepath)){ std::cerr<<"Failed to open hardware decoder for: "<<filepath<<std::endl; return false;} if(!initializeVideoProcessor()){ std::cerr<<"Failed to initialize video processor"<<std::endl; close(); return false;} return true; }
bool RgbVideoDecoder::readNextFrame(DecodedRgbFrame& frame){ if(!isOpen()) return false; frame.is_valid=false; if(!hw_decoder_->readNextFrame(frame.hw_frame)) return false; if(!convertYuvToRgb(frame.hw_frame.frame, frame.rgb_texture)){ std::cerr<<"Failed to convert YUV to RGB"<<std::endl; return false;} frame.is_valid=true; return true; }
bool RgbVideoDecoder::isOpen() const { return hw_decoder_ && hw_decoder_->isOpen() && video_processor_; }
bool RgbVideoDecoder::isEOF() const { return hw_decoder_ && hw_decoder_->isEOF(); }
void RgbVideoDecoder::close(){ cleanup(); if(hw_decoder_) hw_decoder_->close(); }
HwVideoDecoder* RgbVideoDecoder::getHwDecoder() const { return hw_decoder_.get(); }
int RgbVideoDecoder::getWidth() const { return video_width_; }
int RgbVideoDecoder::getHeight() const { return video_height_; }
bool RgbVideoDecoder::initializeVideoProcessor(){ if(!hw_decoder_||!hw_decoder_->isOpen()) return false; ID3D11Device* dev=hw_decoder_->getD3D11Device(); ID3D11DeviceContext* ctx=hw_decoder_->getD3D11DeviceContext(); if(!dev||!ctx) return false; if(FAILED(dev->QueryInterface(__uuidof(ID3D11VideoDevice),(void**)&video_device_))) return false; if(FAILED(ctx->QueryInterface(__uuidof(ID3D11VideoContext),(void**)&video_context_))) return false; MKVStreamReader* sr=hw_decoder_->getStreamReader(); if(!sr) return false; AVCodecParameters* cp=sr->getVideoCodecParameters(); if(!cp) return false; video_width_=cp->width; video_height_=cp->height; D3D11_VIDEO_PROCESSOR_CONTENT_DESC cd{}; cd.InputFrameFormat=D3D11_VIDEO_FRAME_FORMAT_PROGRESSIVE; cd.InputWidth=video_width_; cd.InputHeight=video_height_; cd.OutputWidth=video_width_; cd.OutputHeight=video_height_; cd.Usage=D3D11_VIDEO_USAGE_PLAYBACK_NORMAL; if(FAILED(video_device_->CreateVideoProcessorEnumerator(&cd,&video_processor_enumerator_))) return false; if(FAILED(video_device_->CreateVideoProcessor(video_processor_enumerator_.Get(),0,&video_processor_))) return false; D3D11_TEXTURE2D_DESC td{}; td.Width=video_width_; td.Height=video_height_; td.MipLevels=1; td.ArraySize=1; td.Format=DXGI_FORMAT_B8G8R8A8_UNORM; td.SampleDesc.Count=1; td.Usage=D3D11_USAGE_DEFAULT; td.BindFlags=D3D11_BIND_RENDER_TARGET|D3D11_BIND_SHADER_RESOURCE; td.MiscFlags=D3D11_RESOURCE_MISC_SHARED; if(FAILED(dev->CreateTexture2D(&td,nullptr,&rgb_texture_))) return false; D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC ovd{}; ovd.ViewDimension=D3D11_VPOV_DIMENSION_TEXTURE2D; ovd.Texture2D.MipSlice=0; if(FAILED(video_device_->CreateVideoProcessorOutputView(rgb_texture_.Get(), video_processor_enumerator_.Get(), &ovd,&output_view_))) return false; return true; }
bool RgbVideoDecoder::convertYuvToRgb(AVFrame* yuv, ComPtr<ID3D11Texture2D>& rgb){ if(!yuv||!video_processor_||!video_context_) return false; ID3D11Texture2D* yuv_tex=(ID3D11Texture2D*)yuv->data[0]; if(!yuv_tex) return false; UINT slice=(UINT)(intptr_t)yuv->data[1]; ComPtr<ID3D11VideoProcessorInputView> iv=getOrCreateInputView(yuv_tex,slice); if(!iv) return false; D3D11_VIDEO_PROCESSOR_STREAM sd{}; sd.Enable=TRUE; sd.InputFrameOrField=0; sd.PastFrames=0; sd.FutureFrames=0; sd.pInputSurface=iv.Get(); if(FAILED(video_context_->VideoProcessorBlt(video_processor_.Get(), output_view_.Get(),0,1,&sd))) return false; rgb=rgb_texture_; return true; }
ComPtr<ID3D11VideoProcessorInputView> RgbVideoDecoder::getOrCreateInputView(ID3D11Texture2D* tex, UINT slice){ if(!tex||!video_device_||!video_processor_enumerator_) return nullptr; InputViewKey key{tex,slice}; auto it=input_view_cache_.find(key); if(it!=input_view_cache_.end()) return it->second; ComPtr<ID3D11VideoProcessorInputView> view; D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC ivd{}; ivd.ViewDimension=D3D11_VPIV_DIMENSION_TEXTURE2D; ivd.Texture2D.MipSlice=0; ivd.Texture2D.ArraySlice=slice; if(FAILED(video_device_->CreateVideoProcessorInputView(tex, video_processor_enumerator_.Get(), &ivd, &view))) return nullptr; input_view_cache_[key]=view; return view; }
void RgbVideoDecoder::clearInputViewCache(){ input_view_cache_.clear(); }
void RgbVideoDecoder::cleanup(){ clearInputViewCache(); output_view_.Reset(); rgb_texture_.Reset(); video_processor_.Reset(); video_processor_enumerator_.Reset(); video_context_.Reset(); video_device_.Reset(); video_width_=video_height_=0; }
